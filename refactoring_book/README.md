# 3. 코드에서 나는 악취

## 3.1 기이한 이름

- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 변수 이름 바꾸기
- 필드 이름 바꾸기

## 3.2 중복 코드

- [함수 추출하기](#61-함수-추출하기)
- 문장 슬라이드하기
- 메소드 올리기

## 3.3 긴 함수

- [함수 추출하기](#61-함수-추출하기)
- 임시 변수를 질의 함수로 바꾸기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)
- 객체 통째로 넘기기
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- 조건문을 다형성으로 바꾸기
- 반복문 쪼개기

## 3.4 긴 매개변수 목록

- 매개변수를 질의 함수로 바꾸기
- 객체 통째로 넘기기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)
- 플래그 인수 제거하기
- 여러 함수를 클래스로 묶기

## 3.5 전역 데이터

- [변수 캡슐화하기](#66-변수-캡슐화하기)

## 3.6 가변 데이터

- [변수 캡슐화하기](#66-변수-캡슐화하기)
- 변수 쪼개기
- 문장 슬라이드하기
- [함수 추출하기](#61-함수-추출하기)
- 질의함수와 변경함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기

## 3.7 뒤엉킨 변경

단일 책임 원칙(SRP)이 제대로 지켜지지 않은 경우
한 코드에 여러가지 책임이 섞여있는 상태

- [단계 쪼개기](#611-단계-쪼개기)
- 함수 옮기기
- [함수 추출하기](#61-함수-추출하기)
- 클래스 추출하기

## 3.8 산탄총 수술

하나의 기능이 여러 코드에 흩뿌려진 상태

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- [단계 쪼개기](#611-단계-쪼개기)
- [함수 인라인하기](#62-함수-인라인하기)
- 클래스 인라인하기

## 3.9 기능 편애

- 함수 옮기기
- [함수 추출하기](#61-함수-추출하기)

## 3.10 데이터 뭉치

- 클래스 추출하기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)
- 객체 통째로 넘기기

## 3.11 기본형 집착

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)

## 3.12 반복되는 switch문

- 조건부 로직을 다형성으로 바꾸기

## 3.13 반복문

- 반복문을 파이프라인으로 바꾸기

## 3.14 성의 없는 요소

- [함수 인라인하기](#62-함수-인라인하기)
- 클래스 인라인 하기
- 상속: 계층 합치기

## 3.15 추측성 일반화

- 계층 합치기
- [함수 인라인하기](#62-함수-인라인하기)
- 클래스 인라인하기
- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 죽은 코드 제거하기

## 3.16 임시 필드

- 클래스 추출하기
- 함수 옮기기
- 특이 케이스 추가하기

## 3.17 메세지 체인

- 위임 숨기기
- [함수 추출하기](#61-함수-추출하기)
- 함수 옮기기

## 3.18 중개자

클래스의 대부분의 메소드가 다른 클래스에 구현을 위임한 경우

- 중개자 제거하기
- [함수 인라인하기](#62-함수-인라인하기)

## 3.19 내부자 거래

- 함수 옮기기
- 필드 옮기기
- 위임 숨기기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

## 3.20 거대한 클래스

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기
- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기

## 3.21 서로 다른 인터페이스의 대안 클래스들

- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 함수 옮기기
- 슈퍼클래스 추출하기

## 3.22 데이터 클래스 - DTO

- public field: 레코드 캡슐화하기
- 변형 금지 필드: 세터 제거하기
- 함수 옮기기
- [함수 추출하기](#61-함수-추출하기)

## 3.23 상속 포기

- 메소드 내리기
- 필드 내리기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

## 3.24 주석

- [함수 추출하기](#61-함수-추출하기)
- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 어서션 추가하기

# 04. 테스트 구축하기

## 환경 설정

- mocha, chai package 사용

## 4.4 테스트 추가하기

- 가공 없는 단순 getter, setter 등의 의미없는 테스트 코드 작성 X

## 4.6 경계 조건 검사하기 (경계선 테스트)

- 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트
  - 컬렉션이 empty일 경우
  - 숫자형 값이 0일 경우
  - 숫자형 값이 음수일 경우
  - 숫자형 데이터에 문자열이 들어갈 경우(javascript)

# 06. 기본적인 리팩토링

## 6.1 함수 추출하기

코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 네이밍 부여

- 목적과 구현을 기준으로 분리

- 반대 리팩터링: [함수 인라인하기](#62-함수-인라인하기)
- 함수
  - OOP의 메소드
  - 프로시저, 서브루틴

## 6.2 함수 인라인하기

- 함수의 구현부가 이름만큼 명확한 경우
- 다른 함수로 단순히 위임만 하는 함수들이 많아 위임관계가 얽혀 있는 경우

- 반대 리팩터링: [함수 추출하기](#61-함수-추출하기)

## 6.3 변수 추출하기

표현식이 너무 복잡한 경우, 지역 변수를 생성해 표현식을 쪼갠다.

- 디버깅에 유리

- 반대 리팩터링: [변수 인라인하기](#64-변수-인라인하기)

## 6.4 변수 인라인하기

변수는 함수 안에서 표현식을 가리키는 식별자로 사용됨.
이 때 식별자 자체로 표현식과 차이점이 없으면 변수 인라인

- 반대 리팩터링: [변수 추출하기](#63-변수-추출하기)

## 6.5 함수 선언 바꾸기

- 함수의 이름 바꾸기
- 함수의 매개변수 추가, 제거하기

## 6.6 변수 캡슐화하기

- 데이터를 재구성하는 것은 함수를 재구성하는 것보다 어렵다.
  - 호출할 수 있는 유효범위가 넓기 때문에
- `private` 접근제한자, `getter`, `setter` 메소드를 통해 캡슐화하여 '데이터 재구성'을 '함수 재구성'으로 변환하는 작업
- 데이터 불변성을 위해 `getter` 에서 deep clone하여 반환

## 6.7 변수 이름 바꾸기

- 변수의 이름은 사용범위에 영향을 많이 받음
- 람다식 등 내부에서의 변수명은 그 범위가 명확해서 한 글자로 짓기도 함
- javascript와 같은 동적 타입 언어는 타입을 드러내는 문자를 접두어로 사용
- 넓은 범위에서 영속되는 필드라면 이름에 더욱 신경써야 함
- 폭 넒게 쓰이는 변수라면 [변수 캡슐화하기](#66-변수-캡슐화하기) 고려

## 6.8 매개변수 객체 만들기

```js
function amountInvoiced(startDate, endDate) {...
}

function amountReceived(startDate, endDate) {...
}

function amountOverdue(startDate, endDate) {...
}
```

=>

```js
function amountInvoiced(aDateRange) {...
}

function amountReceived(aDateRange) {...
}

function amountOverdue(aDateRange) {...
}
```

```js
class DateRange {
  constructor(startDate, max) {
    this._data = { startDate: startDate, endDate: endDate };
  }

  get startDate() {
    return this._data.startDate;
  }

  get endDate() {
    return this._data.endDate;
  }
}
```

- 데이터 여러 항목이 파라미터로 묶여 다니는 경우, 객체로 묶어 줌(주로 class 사용)

## 6.9 여러 함수를 클래스로 묶기

- 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 요소와 어우러질 수 있도록 그 중 일부를 외부에 공개
- 여러 메소드가 공통된 파라미터를 사용하는 경우, 클래스로 묶는다.
- 중첩 함수로 묶어도 되지만, 테스트가 어렵기 때문에 class로 묶는 것 선호
- 함수들이 공유하는 공통 데이터 레코드를 캡슐화 ([매개변수 객체 만들기](#68-매개변수-객체-만들기))
  - 이 후, 해당 class 내부에 중복으로 호출되는 함수를 이동

## 6.10 여러 함수를 변환 함수로 묶기

- 변환 함수(transform func): 원본 데이터를 입력받아 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환
  - 내부에서는 불변성을 위해 원본 데이터는 deep clone해서 사용
  - 원본 데이터를 직접 가공, 수정해야할 필요가 있다면, [여러 함수를 클래스로 묶기](#69-여러-함수를-클래스로-묶기) 사용
- 변환함수의 네이밍
  - `enrichA`: 본질은 같고 부가 정보만 덧붙이는 변환함수의 네이밍
  - `transformA` : 형태가 변할 때의 네이밍

## 6.11 단계 쪼개기

```js
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split('-')[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;
```

=>

```js
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString) {
  const values = aString.split(/\s+/);
  return ({
    productID: values[0].split("-")[1],
    quantity: parseInt(values[1]);
  });
}

function price(order, priceList) {
  return order.quantity * priceList[order.productID];
}
```

- 한 코드 안에서 서로 다른 두 대상을 다루는 코드가 있을 경우, 모듈 별로 나눈다.
- 각 모듈에서는 각 단계 별로 집중에해야 할 로직만 수행한다.

---

# 07. 캡슐화

모듈을 분리하는 가장 큰 기준: 외부로 노출할 것을 제외하고 얼마나 잘 숨기는지 여부

1. 레코드 캡슐화하기
2. 컬렉션 캡슐화하기
3. 기본형을 객체로 바꾸기
4. 임시 변수를 질의 함수로 바꾸기
5. 여러 함수를 클래스로 묶기
6. 클래스 추출하기
7. 클래스 인라인하기
8. 위임 숨기기
9. 중재자 제거하기
10. 알고리즘 교체하기

## 7.1 레코드 캡슐화하기

- 리팩토링 책에서 레코드는 데이터를 주고받는 형태를 말하는 듯
- 레코드 중에 자신이 가진 필드명을 외부로 노출하지 않는 아래와 같은 형태가 있음 -> class로 변경
  - javascript의 객체 리터럴로 선언된 경우
  - Hash, Map, HashMap, Dictionary, associative array(유사 배열)을 사용한 경우

## 7.2 컬렉션 캡슐화하기

- 내부 컬렉션을 직접 수정하지 못하도록 처리
  - 컬렉션의 getter에 deep copy를 사용해 복제본 반환
  - `add()`, `remove()` 함수 생성 및 사용

## 7.3 기본형을 객체로 바꾸기

```js
orders.filter((o) => 'high' === o.priority || 'rush' === o.priority);
```

-> (priority: string) 프로퍼티를 객체화

```js
orders.filter((o) => o.priority.higherThan(new Priority('normal')));
```

- 추후에 해당 값을 사용한 추가 로직 개발 시, 용이

## 7.4 임시 변수를 질의 함수로 바꾸기

- 함수 안에서 어떤 코드의 결과값을 뒤에서 다시 참조할 목적으로 임시 변수를 사용
- 이를 함수로 만들어 사용하는 편이 나을 때가 있다.
- 클래스 안에서 적용할 때 효과가 큼
  - 클래스는 추출할 메소드들에 공유 컨텍스트를 제공하기 때문

## 7.5 클래스 추출하기

- 반대 리팩토링: 클래스 인라인하기
- 클래스는 반드시 명확하게 추상화하고 '소수'의 주어진 역할만 수행해야 한다.
- 한 클래스가 너무 큰 역할과 책임을 갖고 있는 경우, 클래스 추출

## 7.6 클래스 인라인하기

- 반대 리팩터링: 클래스 추출하기
- 너무 역할과 책임이 작은 클래스는 인라인 처리
- 또 두 개의 클래스의 기능을 재분배할 때에도 일단 하나의 클래스로 합친 뒤에 새로운 클래스로 추출

## 7.7 위임 숨기기

- 반대 리팩토링: 중개자 제거하기

```js
manager = aPerson.department.manager;
```

->

```js
manager = aPerson.manager;

class Person {
  get manager() {
    return this.department.manager;
  }
}
```

- 캡슐화는 단순히 필드를 숨기는 것이 아님
- 구현부에 위임 메소드를 만들어서 위임 객체의 존재를 호출부에 숨긴다.

## 7.8 중개자 제거하기

```js
manager = aPerson.manager;
```

->

```js
manager = aPerson.department.manager;
```

- 반대 리팩터링: 위임 숨기기
- 구현부(서버 클래스)가 다수의 위임 메소드를 갖고 있어, 서버 클래스가 그저 중개자 역할만 하는 경우

## 7.9 알고리즘 교체하기

```js
const foundPerson = (people) => {
  for (let i = 0; i < people.length; i++) {
    if (people[i] === 'Don') {
      return 'Don';
    }
    if (people[i] === 'John') {
      return 'John';
    }
    if (people[i] === 'Kent') {
      return 'Kent';
    }
  }
  return '';
};
```

->

```js
const foundPerson = (people) => {
  const candidates = ['Don', 'John', 'Kent'];
  return people.find((p) => candidates.includes(p)) || '';
};
```

- 거대하고 복잡한 알고리즘을 교체하기는 어렵기 때문에 알고리즘을 간소화하는 작업부터 진행
