# 3. 코드에서 나는 악취

## 3.1 기이한 이름

- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 변수 이름 바꾸기
- 필드 이름 바꾸기

## 3.2 중복 코드

- [함수 추출하기](#61-함수-추출하기)
- 문장 슬라이드하기
- 메소드 올리기

## 3.3 긴 함수

- [함수 추출하기](#61-함수-추출하기)
- 임시 변수를 질의 함수로 바꾸기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)
- 객체 통째로 넘기기
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- 조건문을 다형성으로 바꾸기
- 반복문 쪼개기

## 3.4 긴 매개변수 목록

- 매개변수를 질의 함수로 바꾸기
- 객체 통째로 넘기기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)
- 플래그 인수 제거하기
- 여러 함수를 클래스로 묶기

## 3.5 전역 데이터

- [변수 캡슐화하기](#66-변수-캡슐화하기)

## 3.6 가변 데이터

- [변수 캡슐화하기](#66-변수-캡슐화하기)
- 변수 쪼개기
- 문장 슬라이드하기
- [함수 추출하기](#61-함수-추출하기)
- 질의함수와 변경함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기

## 3.7 뒤엉킨 변경

단일 책임 원칙(SRP)이 제대로 지켜지지 않은 경우
한 코드에 여러가지 책임이 섞여있는 상태

- 단계 쪼개기
- 함수 옮기기
- [함수 추출하기](#61-함수-추출하기)
- 클래스 추출하기

## 3.8 산탄총 수술

하나의 기능이 여러 코드에 흩뿌려진 상태

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기
- [함수 인라인하기](#62-함수-인라인하기)
- 클래스 인라인하기

## 3.9 기능 편애

- 함수 옮기기
- [함수 추출하기](#61-함수-추출하기)

## 3.10 데이터 뭉치

- 클래스 추출하기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)
- 객체 통째로 넘기기

## 3.11 기본형 집착

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- [매개변수 객체 만들기](#68-매개변수-객체-만들기)

## 3.12 반복되는 switch문

- 조건부 로직을 다형성으로 바꾸기

## 3.13 반복문

- 반복문을 파이프라인으로 바꾸기

## 3.14 성의 없는 요소

- [함수 인라인하기](#62-함수-인라인하기)
- 클래스 인라인 하기
- 상속: 계층 합치기

## 3.15 추측성 일반화

- 계층 합치기
- [함수 인라인하기](#62-함수-인라인하기)
- 클래스 인라인하기
- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 죽은 코드 제거하기

## 3.16 임시 필드

- 클래스 추출하기
- 함수 옮기기
- 특이 케이스 추가하기

## 3.17 메세지 체인

- 위임 숨기기
- [함수 추출하기](#61-함수-추출하기)
- 함수 옮기기

## 3.18 중개자

클래스의 대부분의 메소드가 다른 클래스에 구현을 위임한 경우

- 중개자 제거하기
- [함수 인라인하기](#62-함수-인라인하기)

## 3.19 내부자 거래

- 함수 옮기기
- 필드 옮기기
- 위임 숨기기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

## 3.20 거대한 클래스

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기
- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기

## 3.21 서로 다른 인터페이스의 대안 클래스들

- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 함수 옮기기
- 슈퍼클래스 추출하기

## 3.22 데이터 클래스 - DTO

- public field: 레코드 캡슐화하기
- 변형 금지 필드: 세터 제거하기
- 함수 옮기기
- [함수 추출하기](#61-함수-추출하기)

## 3.23 상속 포기

- 메소드 내리기
- 필드 내리기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

## 3.24 주석

- [함수 추출하기](#61-함수-추출하기)
- [함수 선언 바꾸기](#65-함수-선언-바꾸기)
- 어서션 추가하기

# 04. 테스트 구축하기

## 환경 설정

- mocha, chai package 사용

## 4.4 테스트 추가하기

- 가공 없는 단순 getter, setter 등의 의미없는 테스트 코드 작성 X

## 4.6 경계 조건 검사하기 (경계선 테스트)

- 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트
  - 컬렉션이 empty일 경우
  - 숫자형 값이 0일 경우
  - 숫자형 값이 음수일 경우
  - 숫자형 데이터에 문자열이 들어갈 경우(javascript)

# 06. 기본적인 리팩토링

## 6.1 함수 추출하기

코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 네이밍 부여

- 목적과 구현을 기준으로 분리

- 반대 리팩터링: [함수 인라인하기](#62-함수-인라인하기)
- 함수
  - OOP의 메소드
  - 프로시저, 서브루틴

## 6.2 함수 인라인하기

- 함수의 구현부가 이름만큼 명확한 경우
- 다른 함수로 단순히 위임만 하는 함수들이 많아 위임관계가 얽혀 있는 경우

- 반대 리팩터링: [함수 추출하기](#61-함수-추출하기)

## 6.3 변수 추출하기

표현식이 너무 복잡한 경우, 지역 변수를 생성해 표현식을 쪼갠다.

- 디버깅에 유리

- 반대 리팩터링: [변수 인라인하기](#64-변수-인라인하기)

## 6.4 변수 인라인하기

변수는 함수 안에서 표현식을 가리키는 식별자로 사용됨.
이 때 식별자 자체로 표현식과 차이점이 없으면 변수 인라인

- 반대 리팩터링: [변수 추출하기](#63-변수-추출하기)

## 6.5 함수 선언 바꾸기

- 함수의 이름 바꾸기
- 함수의 매개변수 추가, 제거하기

## 6.6 변수 캡슐화하기

- 데이터를 재구성하는 것은 함수를 재구성하는 것보다 어렵다.
  - 호출할 수 있는 유효범위가 넓기 때문에
- `private` 접근제한자, `getter`, `setter` 메소드를 통해 캡슐화하여 '데이터 재구성'을 '함수 재구성'으로 변환하는 작업
- 데이터 불변성을 위해 `getter` 에서 deep clone하여 반환

## 6.7 변수 이름 바꾸기

- 변수의 이름은 사용범위에 영향을 많이 받음
- 람다식 등 내부에서의 변수명은 그 범위가 명확해서 한 글자로 짓기도 함
- javascript와 같은 동적 타입 언어는 타입을 드러내는 문자를 접두어로 사용
- 넓은 범위에서 영속되는 필드라면 이름에 더욱 신경써야 함
- 폭 넒게 쓰이는 변수라면 [변수 캡슐화하기](#66-변수-캡슐화하기) 고려

## 6.8 매개변수 객체 만들기

```js
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}
```

=>

```js
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

```js
class DateRange {
  constructor(startDate, max) {
    this._data = { startDate: startDate, endDate: endDate };
  }
  get startDate() {
    return this._data.startDate;
  }
  get endDate() {
    return this._data.endDate;
  }
}
```

- 데이터 여러 항목이 파라미터로 묶여 다니는 경우, 객체로 묶어 줌(주로 class 사용)

## 6.9 여러 함수를 클래스로 묶기
- 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 요소와 어우러질 수 있도록 그 중 일부를 외부에 공개
- 여러 메소드가 공통된 파라미터를 사용하는 경우, 클래스로 묶는다.
- 중첩 함수로 묶어도 되지만, 테스트가 어렵기 때문에 class로 묶는 것 선호
- 함수들이 공유하는 공통 데이터 레코드를 캡슐화 ([매개변수 객체 만들기](#68-매개변수-객체-만들기))
  - 이 후, 해당 class 내부에 중복으로 호출되는 함수를 이동

## 6.10 여러 함수를 변환 함수로 묶기
- 변환 함수(transform func): 원본 데이터를 입력받아 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환
  - 내부에서는 불변성을 위해 원본 데이터는 deep clone해서 사용
  - 원본 데이터를 직접 가공, 수정해야할 필요가 있다면, [여러 함수를 클래스로 묶기](#69-여러-함수를-클래스로-묶기) 사용
- 변환함수의 네이밍
  - `enrichA`: 본질은 같고 부가 정보만 덧붙이는 변환함수의 네이밍
  - `transformA` :  형태가 변할 때의 네이밍
