## 목차



스택, 큐, 연결 리스트는 모두 **순차(sequential) 자료구조**

### 3장. 스택 Stack

### 4장. 큐 Queue
- 큐

- 우선순위 큐

- 환형 큐

  dequeue한 값을 그대로 enqueue 해, 환형 구조를 갖게 한다.

### 5장. 연결 리스트 Linked List

- 연결 리스트

  리스트의 시작 원소(head) 부터 순회를 시작한다.

  node의 next 프로퍼티에 다음 값의 참조를 갖는다. (사실상 중첩 객체인 듯..)

- 이중 연결 리스트

  node에 next 뿐만 아니라 prev의 프로퍼티를 추가한다. 즉, 이전 값을 갖게 되어 리스트의 마지막(tail) 부터 순회가 가능하다.

### 6장. 집합 Set

순차 자료구조가 아닌 **집합 자료 구조**

- 정렬되지 않으며
- 중복되지 않는다

집합 연산

- 합집합 : 두 집합 중 어느 한쪽이라도 포함된 원소로 구성된 집합
- 교집합: 두 집합 중 모두 포함되어 있는 원소로 구성된 집합
- 차집합: 첫 번째 집합에는 있지만, 두번 째 집합에는 없는 원소들의 집합
- 부분집합: 어떤 집합이 다른 집합의 일부인 지 확인



### 7장. 딕셔너리와 해시

딕셔너리와 해시 모두 유일한 값을 저장하기 위한 자료구조

집합이 원소의 값(value) 에만 초점을 두었다면, 딕셔너리, 해시는 [key, value] 형태로 저장

**딕셔너리** (맵)

- key로써 value를 찾는다.

**해시 테이블 hash table** 

- **hashing**: 자료 구조에서 특정 값을 가장 신속하게 찾는 방법

  hash값을 만들어 해당 hash 값을 key해서  {key, value}를 value로 바인딩한다.

  

- **해시 함수** :  어떤 키에 해당하는 값의 주소를 테이블에서 찾을 수 있도록  코드(hash 값)를 생성하는 함수이므로 조회속도가 매우 빠르고 간단해야 한다..

  - ```js
     // 해시 함수 개선(djb2 해시 함수) :: 전문가들이 즐겨 쓰는 해시 함수 중 하나
      djb2HashCode(key) {
        let hash = 5381; // 임의의 소수
        for (let i = 0; i < key.length; i++) {
          hash = hash * 33 + key.charCodeAt(i);
        }
        return hash % 1013;
      }
    ```

    

- **hash table 간 충돌**

  다른 key 로 hash 값을 만들었지만, **hash 값이 같게 되어**, 데이터간 충돌이 발생하는 경우

  충돌을 해결하는 방법으로 체이닝, 선형 탐사, 이중 해싱 등이 있다.

  

  - 체이닝(separate chaining)

    해시 값 별로 연결리스트를 생성해 그 안에 원소를 저장하는 기법

    즉, 해시값의 value로 linkedList가 들어가고 해당 linkedList에서 key 값으로 value를 찾아낸다.
    
    hahtable 인스턴스 외에 메모리가 추가적으로 소요된다는 단점 존재
    
    
    
  - 선형 탐색법 (linear probing)

    새 원소 추가 시, 인덱스가 이미 점유된 상태라면, index+1 을 찾아보고, 인덱스 +1도 점유되었다면, 인덱스 + 2를 찾아보는 식으로 충돌 회피

 

### 8장. 트리 Tree

- 비순차적 자료 구조
- 정보를 쉽게 검색하기 위해 저장할 때 유용한 자료 구조

용어

- 루트: 최상위 노드 , 부모가 없다
- 내부 노드 : 한 개 이상의 자식을 가진 노드
- 외부 노드, Leaf : 자식이 하나도 없는 노드
- 서브 트리: 노드와 후손들로 구성
- depth: 조상의 개수
- height: 깊이의 최대치

이진 트리, 이진 탐색 트리

- **이진 트리(Binary tree)**: 노드는 좌, 우 각각 하나씩, 총 최대 2개의 자식 노드를 갖는다.

  노드의 삽입, 조회, 삭제가 효과적

- **이진 탐색 트리(Binary Search tree)**: 이진 트리의 변형으로 좌측 자식 노드에는 더 작은 값을, 우측 자식 노드에는 더 큰 값을 들고 있다.

  최소값은 가장 마지막 level, 가장 좌측의 값 / 최대값은 가장 마지막 level, 가장 우측의 값

- 트리 순회

  트리의 모든 노드를 방문해 각 노드마다 어떤 작업을 수행하는 것

  순회하는 방법에 따라 다음과 같이 분류

  1. **중위 순회(in order traversal)**

     오름차순, 즉 작은 값에서 큰 값의 방향으로 방문

     트리 정렬 시 사용되는 방법

  2. **전위 순회(pre-order traversal)**

     자식노드보다 노드 자신이 먼저 콜백함수 실행

     구조화된 문서를 출력할 때 많이 이용

  3. **후위 순회(post-order traversal)** 

     자기 자신을 가장 나중에 실행

     서브 디렉토리의 파일 용량을 계산할 때 쓰는 방법

  

### 9장. 그래프

비 선형 자료구조

네트워크 구조를 추상화한 모델

간선(edge)으로 연결된 노드(node, 정점)의 집합

용어

- 인접 정점: 간선으로 연결된 정점
- 차수(degree): 인접 정점의 개수
- 경로(path): 일련의 연속된 정점
- 단순 경로(simple path): 반복된 정점을 포함하지 않는 경로 `?`
- 사이클(cycle): 처음과 정점이 같은 단순 경로

방향 / 무방향 그래프

- 두 정점이 양방향의 경로를 갖고 있을 때, **강결합**

가중치가 있는 그래프 (Weighted graph)

- 간선마다 가중치 가 존재

순회

방문을 마친 정점의 리스트를 저장하는 자료 구조에 따라 나뉜다.

- BFS: queue  - 가장 오래 전에 방문하지 않은 정점을 먼저 방문

- DFS: stack - 경로를 따라 정점을 찾아가면서 인접 정점이 있으면 방문

1. **너비 우선 탐색(BFS; breadth-first search)**

   시작 정점에서 순회를 시작해 그래프를 한 번에 한 층씩, 우선 이웃한 정접(인접 정점)들을 모두 방문한다.

   방문하며 찾은 인접 노드들의 인접 노드들은 Queue 에 들어가기 때문에, 먼저 인접노드를 방문한 후에 dequeue된다.

   - **가중치 그래프**에서 최단 거리를 구할 때에는 BFS가 무용지물이므로 다음 알고리즘 사용
     - 다익스트라 알고리즘
     - 벨만-포드 알고리즘
     - A* 검색 알고리즘
     - 플로이드-워셜 알고리즘

   

2. **깊이 우선 탐색(DFS; depth-first search)**

   시작 정점에서 출발해 동일 경로의 마지막 정점까지 순회하고, 상위 정점으로 돌아와 다음 경로를 탐색

   시작 정점이 필요없다.

   재귀 함수를 호출하며 callstack에 함수를 쌓으므로  stack 구조가 생성

   **백트래킹 backtracking**

   ​	: 해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면, 그 경로를 더 이상 탐색하지 않고, 다시 되돌아간다.

   ​	불필요한 경로를 조기에 차단할 수 있게 되어 경우의 수가 줄어들게 된다.(**가지치기** 개념)

   ​	즉, 백트래킹은 모든 가능한 경우의 수 중에서 **특정한 조건을 만족하는 경우에만 탐색을 계속하는 것**

   

### 10장. 정렬과 검색 알고리즘

1. 버블 정렬 Bubble Sort

   모든 요소를 순회하며, 대소 비교 후, 각 요소의 순서를 바꾼다.

   복잡도  O(n^2)

2. 선택 정렬 Selection Sort

   제자리 정렬 알고리즘의 하나로 최소값을 찾아 맨 앞으로 보내고, 그 다음 작은 값을 찾아 2번째 위치로 보내는 식으로 정렬

   복잡도  O(n^2)

3. 삽입 정렬 Insertion sort

   한 번에 한 원소 씩 정렬된 배열을 만들어가는 알고리즘

   앞의 원소와 비교해 작은 원소를 가장 앞으로 정렬

   크기가 작은 배열이라면 삽입 정렬은 선택 정렬, 버블 정렬보다 성능이 우수하다.

   복잡도  O(n^2)

4. 병합 정렬 Merge Sort

   복잡도 O(n log n)

   핵심은 분할과 정복

   정렬할 배열을 원소가 하나뿐인 배열 단위로 나뉠 때까지 분할하고, 반대로 이렇게 분할된 배열을 점점 더 큰 배열로 병합하면서 정렬 완성
   
5. 퀵 정렬 Quick Sort

   가장 애용되는 정렬 알고리즘

   복잡도 O(n log n)

   분할/정복 방식으로 접근

   용어

    1. 피봇 Pivot : 배열의 중간 지점에 위치한 원소

    2. 파티션 Partition

       a. 2개의 포인터(첫 번째 원소와 마지막 원소의 포인터)를 생성한 후

       b. 피봇보다 큰 원소가 나올 때까지 좌측 포인터를 움직이고, 반대로 피봇보다 작은 원소가 나올 때까지 우측 포인터를 움직인다. 

       c. 해당하는 원소를 서로 교환한다.

       d. 위의 과정을 좌측 포인터가 우측 포인터보다 더 커질 때까지 반복

       e. 따라서 피봇보다 작은 원소는 좌측에, 피봇보다 큰 원소는 우측에 자리하게 된다.

       f. 이렇게 나뉜 서브 배열들에 대해 재귀적으로 반복
