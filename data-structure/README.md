## 목차



스택, 큐, 연결 리스트는 모두 **순차(sequential) 자료구조**

### 3장. 스택 Stack

### 4장. 큐 Queue
- 큐

- 우선순위 큐

- 환형 큐

  dequeue한 값을 그대로 enqueue 해, 환형 구조를 갖게 한다.

### 5장. 연결 리스트 Linked List

- 연결 리스트

  리스트의 시작 원소(head) 부터 순회를 시작한다.

  node의 next 프로퍼티에 다음 값의 참조를 갖는다. (사실상 중첩 객체인 듯..)

- 이중 연결 리스트

  node에 next 뿐만 아니라 prev의 프로퍼티를 추가한다. 즉, 이전 값을 갖게 되어 리스트의 마지막(tail) 부터 순회가 가능하다.

### 6장. 집합 Set

순차 자료구조가 아닌 **집합 자료 구조**

- 정렬되지 않으며
- 중복되지 않는다

집합 연산

- 합집합 : 두 집합 중 어느 한쪽이라도 포함된 원소로 구성된 집합
- 교집합: 두 집합 중 모두 포함되어 있는 원소로 구성된 집합
- 차집합: 첫 번째 집합에는 있지만, 두번 째 집합에는 없는 원소들의 집합
- 부분집합: 어떤 집합이 다른 집합의 일부인 지 확인



### 7장. 딕셔너리와 해시

딕셔너리와 해시 모두 유일한 값을 저장하기 위한 자료구조

집합이 원소의 값(value) 에만 초점을 두었다면, 딕셔너리, 해시는 [key, value] 형태로 저장

**딕셔너리** (맵)

- key로써 value를 찾는다.

**해시 테이블 hash table** 

- **hashing**: 자료 구조에서 특정 값을 가장 신속하게 찾는 방법

  해시 함수는 어떤 키에 해당하는 값의 주소를 테이블에서 찾아주는 함수이므로 조회속도가 매우 빠르고 간단하다.

- **hash table 간 충돌**

  다른 key 로 hash 값을 만들었지만, **hash 값이 같게 되어**, 데이터간 충돌이 발생하는 경우

  충돌을 해결하는 방법으로 체이닝, 선형 탐사, 이중 해싱 등이 있다.

  - 체이닝(separate chaining)

    해시 값 별로 연결리스트를 생성해 그 안에 원소를 저장하는 기법

    hahtable 인스턴스 외에 메모리가 추가적으로 소요된다는 단점 존재
